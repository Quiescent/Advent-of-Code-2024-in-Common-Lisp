(defpackage 2024-day-16
  (:use :cl :iterate :cl-ppcre :metabang-bind :trivia :trivia.ppcre)
  (:shadowing-import-from :arrow-macros :->>))
(in-package 2024-day-16)
(neat-lambda:enable-lambda-syntax)
(currying:enable-currying-syntax)

(defun read-problem ()
  (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2024 "src/2024-day-16.in"))
    (labels ((recur ()
               (bind ((line (read-line f nil nil)))
                 (when line
                   (cons line (recur))))))
      (map 'vector #'identity (recur)))))

(defun best-path (grid start)
  (bind ((xs   (make-instance 'cl-heap:priority-queue))
         (best (make-hash-table :test #'equal))
         (fin  most-positive-fixnum))
    (labels ((grid-aref (c)
               (aref (aref grid (imagpart c))
                     (realpart c)))
             (consider-for-queue (c dir dist)
               ;; (format t "consider: (list c dir dist): ~a~%" (list c dir dist))
               (bind ((nc (+ c dir))
                      (n-dist (+ dist 1)))
                 (when (not (char-equal #\# (grid-aref nc)))
                   (bind ((key (cons nc dir))
                          (b (gethash key best)))
                     (when (or (null b) (> b n-dist))
                       ;; (format t "Enqueued~%")
                       (setf (gethash key best) n-dist)
                       (cl-heap:enqueue xs (list nc dir n-dist) n-dist))))))
             (recur ()
               (bind ((next (cl-heap:dequeue xs)))
                 (when next
                   (bind (((c dir dist) next)
                          (b (gethash (cons c dir) best))
                          (s (grid-aref c)))
                     ;; (format t "recur: (list c dir dist): ~a~%" (list c dir dist))
                     (cond
                       ((char-equal s #\E) (setf fin (min dist fin)))
                       ((> dist fin) t)
                       ((= dist b)
                        (bind ((l (* dir #c(0 1)))
                               (r (* dir #c(0 -1))))
                          (consider-for-queue c l (+ dist 1000))
                          (consider-for-queue c r (+ dist 1000))
                          (consider-for-queue c dir dist))))
                     (recur))))))
      (cl-heap:enqueue xs (list start #c(1 0) 0) 0)
      (setf (gethash (cons start #c(1 0)) best) 0)
      (recur)
      fin)))

(defun part-1 ()
  (bind ((grid (read-problem)))
    (best-path grid (complex 1 (- (length (aref grid 0)) 2)))))

(defun best-path-2 (grid start)
  (bind ((xs   (make-instance 'cl-heap:priority-queue))
         (best (make-hash-table :test #'equal))
         (from (make-hash-table :test #'equal))
         (fin  most-positive-fixnum))
    (labels ((grid-aref (c)
               (aref (aref grid (imagpart c))
                     (realpart c)))
             (consider-for-queue (c dir dist)
               ;; (format t "consider: (list c dir dist): ~a~%" (list c dir dist))
               (bind ((nc (+ c dir))
                      (n-dist (+ dist 1)))
                 (when (not (char-equal #\# (grid-aref nc)))
                   (bind ((key (cons nc dir))
                          (b (gethash key best)))
                     (cond
                       ;; ((and b (= b n-dist))
                       ;;  (push c (gethash nc from)))
                       ((or (null b) (> b n-dist))
                        ;; (format t "Enqueued: ~a: ~a~%" key n-dist)
                        (setf (gethash key from) (list c))
                        (setf (gethash key best) n-dist)
                        (cl-heap:enqueue xs (list nc dir n-dist) n-dist)))))))
             (recur ()
               (bind ((next (cl-heap:dequeue xs)))
                 (when next
                   (bind (((c dir dist) next)
                          (b (gethash (cons c dir) best))
                          (s (grid-aref c)))
                     ;; (format t "recur: (list c dir dist): ~a~%" (list c dir dist))
                     (cond
                       ((char-equal s #\E) (setf fin (min dist fin)))
                       ((> dist fin) t)
                       ((= dist b)
                        (bind ((l (* dir #c(0 1)))
                               (r (* dir #c(0 -1))))
                          (consider-for-queue c l (+ dist 1000))
                          (consider-for-queue c r (+ dist 1000))
                          (consider-for-queue c dir dist))))
                     (recur))))))
      (cl-heap:enqueue xs (list start #c(1 0) 0) 0)
      (setf (gethash (cons start #c(1 0)) best) 0)
      (recur)
      (cons from fin))))

(defun trace-back (grid paths start end points)
  (bind ((seen (make-hash-table :test #'equal))
         (in-shortest (make-hash-table :test #'equal)))
    (labels ((recur (c rem p-dir xs)
               (format t "(list c rem p-dir): ~a~%" (list c rem p-dir))
               (cond
                 ((< rem 0) nil)
                 ((= c start) (iter
                                (for x in (print xs))
                                (setf (gethash x in-shortest) t)))
                 (t (iter
                      (for dir in (list #c(1 0) #c(-1 0) #c(0 1) #c(0 -1)))
                      (iter
                        (for nc in (gethash (cons c dir) paths))
                        (for b = (gethash (cons nc dir) seen))
                        (when (or (not b) (> rem b))
                          (setf (gethash (cons nc dir) seen) rem)
                          (recur nc (- rem 1 (if (/= dir p-dir) 1000 0)) dir (cons nc xs)))))))))
      (recur end points #c(0 -1) nil)
      (iter
        (for (key val) in-hashtable in-shortest)
        (for coord = key)
        (setf (aref (aref grid (imagpart coord))
                    (realpart coord))
              #\O))
      (fresh-line)
      (iter
        (for row in-vector grid)
        (iter
          (for c in-string row)
          (princ c))
        (fresh-line))
      (hash-table-count in-shortest))))

(defun best-path-3 (grid start)
  (bind ((xs   (make-instance 'cl-heap:priority-queue))
         (best (make-hash-table :test #'equal))
         (fin  most-positive-fixnum))
    (labels ((grid-aref (c)
               (aref (aref grid (imagpart c))
                     (realpart c)))
             (consider-for-queue (c dir dist)
               ;; (format t "consider: (list c dir dist): ~a~%" (list c dir dist))
               (bind ((nc (+ c dir))
                      (n-dist (+ dist 1)))
                 (when (not (char-equal #\# (grid-aref nc)))
                   (bind ((key (cons nc dir))
                          (b (gethash key best)))
                     (when (or (null b) (> b n-dist))
                       ;; (format t "Enqueued~%")
                       (setf (gethash key best) n-dist)
                       (cl-heap:enqueue xs (list nc dir n-dist) n-dist))))))
             (recur ()
               (bind ((next (cl-heap:dequeue xs)))
                 (when next
                   (bind (((c dir dist) next)
                          (b (gethash (cons c dir) best))
                          (s (grid-aref c)))
                     ;; (format t "recur: (list c dir dist): ~a~%" (list c dir dist))
                     (cond
                       ((char-equal s #\E) (setf fin (min dist fin)))
                       ((> dist fin) t)
                       ((= dist b)
                        (bind ((l (* dir #c(0 1)))
                               (r (* dir #c(0 -1))))
                          (consider-for-queue c l (+ dist 1000))
                          (consider-for-queue c r (+ dist 1000))
                          (consider-for-queue c dir dist))))
                     (recur))))))
      (cl-heap:enqueue xs (list start #c(1 0) 0) 0)
      (setf (gethash (cons start #c(1 0)) best) 0)
      (recur)
      fin)))

(defun part-2 ()
  (bind ((grid (read-problem))
         (start (complex 1 (- (length (aref grid 0)) 2)))
         ((paths . points) (best-path-2 grid start))
         (end (complex (- (length (aref grid 0)) 2) 1)))
    (trace-back grid paths start end points)))
