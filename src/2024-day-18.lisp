(defpackage 2024-day-18
  (:use :cl :iterate :cl-ppcre :metabang-bind :trivia :trivia.ppcre)
  (:shadowing-import-from :arrow-macros :->>))
(in-package 2024-day-18)
(neat-lambda:enable-lambda-syntax)
(currying:enable-currying-syntax)

(defun read-problem ()
  (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2024 "src/2024-day-18.in"))
    (labels ((recur ()
               (bind ((line (read-line f nil nil)))
                 (when line
                   (cons (bind (((x y) (->> (all-matches-as-strings "(\\d+)" line) (mapcar #'read-from-string))))
                           (complex x y))
                         (recur))))))
      (recur))))

(defun grid-set (grid c x)
  (setf (aref grid (imagpart c) (realpart c)) x))

(defun grid-get (grid c)
  (aref grid (imagpart c) (realpart c)))

(defun fill-grid (grid bytes)
  (iter
    (for c in bytes)
    (grid-set grid c t)))

(defun part-1 ()
  (bind ((bytes (subseq (read-problem) 0 1024))
         (grid (make-array (list 71 71) :initial-element nil))
         (seen (make-hash-table :test #'equal))
         (xs (make-instance 'cl-heap:priority-queue))
         (end (complex 70 70)))
    (fill-grid grid bytes)
    (labels ((in-bounds (c)
               (and (>= (realpart c) 0)
                    (>= (imagpart c) 0)
                    (< (realpart c) 71)
                    (< (imagpart c) 71)))
             (recur ()
               (bind ((next (cl-heap:dequeue xs)))
                 (when (not (null next))
                   (bind (((c dist) next))
                     (when (or (/= c end)
                               (and (not (null (gethash c seen)))
                                    (/= dist (gethash c seen)))
                               (< dist (gethash end seen most-positive-fixnum)))
                       (iter
                         (for d in (list #c(1 0) #c(-1 0) #c(0 1) #c(0 -1)))
                         (for nc = (+ d c))
                         (when (or (not (in-bounds nc))
                                   (grid-get grid nc))
                           (next-iteration))
                         (for n-dist = (1+ dist))
                         (for p-dist = (gethash nc seen most-positive-fixnum))
                         (when (< n-dist p-dist)
                           (setf (gethash nc seen) n-dist)
                           (cl-heap:enqueue xs (list nc n-dist) n-dist)))
                       (recur)))))))
      (cl-heap:enqueue xs (list (complex 0 0) 0) 0)
      (recur)
      (gethash end seen))))

(defun part-2 ()
  (bind ((bytes (read-problem))
         (initial-bytes (subseq bytes 0 1024))
         (other-bytes (subseq bytes 1024))
         (grid (make-array (list 71 71) :initial-element nil))
         (seen (make-hash-table :test #'equal))
         (xs (make-instance 'cl-heap:priority-queue))
         (end (complex 70 70)))
    (fill-grid grid initial-bytes)
    (labels ((in-bounds (c)
               (and (>= (realpart c) 0)
                    (>= (imagpart c) 0)
                    (< (realpart c) 71)
                    (< (imagpart c) 71)))
             (recur ()
               (bind ((next (cl-heap:dequeue xs)))
                 (when (not (null next))
                   (bind (((c dist) next))
                     (when (or (/= c end)
                               (and (not (null (gethash c seen)))
                                    (/= dist (gethash c seen)))
                               (< dist (gethash end seen most-positive-fixnum)))
                       (iter
                         (for d in (list #c(1 0) #c(-1 0) #c(0 1) #c(0 -1)))
                         (for nc = (+ d c))
                         (when (or (not (in-bounds nc))
                                   (grid-get grid nc))
                           (next-iteration))
                         (for n-dist = (1+ dist))
                         (for p-dist = (gethash nc seen most-positive-fixnum))
                         (when (< n-dist p-dist)
                           (setf (gethash nc seen) n-dist)
                           (cl-heap:enqueue xs (list nc n-dist) n-dist)))
                       (recur)))))))
      (iter
        (for byte in other-bytes)
        (fill-grid grid (list byte))
        (setf seen (make-hash-table :test #'equal))
        (setf xs (make-instance 'cl-heap:priority-queue))
        (cl-heap:enqueue xs (list (complex 0 0) 0) 0)
        (recur)
        (finding (format t "~a,~a" (realpart byte) (imagpart byte))
                 such-that (null (gethash end seen)))))))
